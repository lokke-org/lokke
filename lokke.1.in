.\" The macros used below are those described in groff_man(7)
.
.TH lokke 1 2020\-08\-27 "@VERSION@"
.
.SH NAME
lokke \- a Clojure dialect for Guile
.
.SH SYNOPSIS
.SY lokke
.RB ( help | \-\-help | \-h | \-? )
.YS
.SY lokke
.RB [ repl ]
.YS
.SY lokke
.B \-0
.YS
.SY lokke
.B run
.OP \-l path
.OP \-e expr
.OP \-a func
.RB [ RUN_OPT
\&.\|.\|.\&]
.RB [ \-\-
.B arg
\&.\|.\|.\&]
.YS
.SY lok
.RB ( \-\-help | \-h | \-? )
.YS
.SY lok
.OP \-l path
.OP \-e expr
.OP \-a func
.RB [ RUN_OPT
\&.\|.\|.\&]
.RB [ \-\-
.B arg
\&.\|.\|.\&]
.YS
.
.SH DESCRIPTION
Lokke is a Clojure dialect for Guile, and may be invoked in two ways.
.B lokke
is the most general command, acting as specified by an initial
subcommand argument (e.g.
.BR repl ,
.BR run ,
etc.), while
.B lok
is a convenience for interactive use, and behaves exactly as if
.B lokke run
had been invoked with the same arguments.  When no arguments are
provided, both commands present an interactive Read-Eval-Print-Loop
(REPL) on the terminal.
.P
Any
.BR arg s
will be available as
.B *command\-line\-args*
in Clojure, and must be delimited from the others by
.BR \-\- .
.P
The
.B \-0
option allows lokke to act as a script interpreter in a flexible,
portable manner, given that the handling of
.B #!
interpeter lines is not standardized across platforms.  See
.B SCRIPT EVALUATION
below for additional information.
.P
Unless otherwise specified, and unlike Guile, lokke sets Guile's
.B *random\-state*
at startup to a value generated by Guile's
.BR random\-state\-from\-platform ,
meaning that
.B rand\-int
values, for example, will usually differ across invocations.
.P
You can invoke
.B lokke run ... \-e guile.guile/%load\-path
or
.B lok ... \-e guile.guile/%load\-path
to display the Guile load path (including any dependencies) for a
given invocation.
.
.SH RUN_OPT
.TP
.BI \-l \fR,\ \fB\-\-load \fI\ file
Execute code in file.
.TP
.BI \-e \fR,\ \fB\-\-eval \fI\ code
Evaluate code, printing any values that are not nil or unspecified.
.TP
.BI \-a \fR,\ \fB\-\-apply \fI\ some.ns/function
Apply some.ns/function to the
.BR *command\-line\-args* .
.TP
.B \-
Execute any code provided on standard input.
.TP
.I file
Execute code in
.IR file ,
which must not start with a dash (\-).
.TP
.BI \-\-seed \fB\ sys
Initialize the *random\-state* (which affects calls like rand\-int) at
startup in a platform-specific way. Insufficient for security-critical
applications.
.TP
.BI \-\-seed \fI\ integer
Initialize the *random\-state* at startup using the given
.IR integer .
.TP
.B \-\-no\-seed
Suppress the default, implicit
.BI \-\-seed \fB\ sys
at startup.  The rightmost seed related argument determines the
startup behavior.
.
.SH SCRIPT EVALUATION
If, and only if, you don't need to specify any additional arguments,
you may begin your scripts like this:
.P
.RS
.EX
#!/path/to/lokke-@LOKKE_MAJOR_VERSION@ -0 ;; -*-clojure-*-
!#
(prn :hello-world)
\&.\|.\|.\&
.EE
.RE
.P
When lokke executes the program, the content between the
.B #!
.B !#
pair is ignored as a block comment, just as with Guile itself.
.P
Whenever you do need to specify additional arguments, you should not
put them on the
.B #!
line because the handling of additional text on that line varies from
platform to platform.  Sometimes the remainder of the line becomes a
single arrgument, sometimes it is split on whitespace, and (more
rarely), sometimes part of the line is ignored.

Accordingly, if you need to make adjustments, you may do something
like this:
.P
.RS
.EX
#!/path/to/lokke-@LOKKE_MAJOR_VERSION@ -0 ;; -*-clojure-*-
;; We're in a Guile preamble module defining a procedure for each
;; lokke subcommand.
(apply run "-l" %0 "--" %&)
!#

;; Place your Clojure code here, after the !#
(prn :hello-world)
\&.\|.\|.\&
.EE
.RE
.P
This will behave exactly the same as the previous example.  When no
code is provided in the block comment, lokke will act as if
.B (apply run """\-l""" %0 """\-\-""" %&)
had been specified, but you can of course adjust the
.B run
invocation to suit your needs, or provide something else entirely.
.P
Everything after the
.B \-0
and before the
.B !#
is executed as Scheme code by Guile in a module that has definitions
for each of the lokke subcommands.  Note that the code Guile executes
will begin with the character immediately after the zero in
.B \-0
no matter what it is (i.e. even if it is not whitespace).  The zero
actually specifies a compatibility level, and for now zero is the only
valid number.
.P
As you may have guessed, the preamble module binds
.B %0
to the script path (like
.B $0
in POSIX shells),
.B %&
to a list of all of the subsequent command line arguments, and
.BR %1 ,
.BR %2 ,
etc. to the elements of
.BR %& .
.P
At the moment lokke is not a binary executable.  If the system
requires #! interpreters to be binary executables, or if you'd like to
locate lokke via the current PATH, you may be able to rely on env like
this:
.P
.RS
.EX
#!/usr/bin/env lokke-@LOKKE_MAJOR_VERSION@ -0
\&.\|.\|.\&
.EE
.RE
.
.SH READLINE SUPPORT
Assuming your guile was compiled with readline support, it's likely
you'll want to add something like this to
.B ~/.lokke_guile
to enable it in the REPL:
.P
.RS
.EX
;;; -*-scheme-*-
(use-modules (ice-9 readline))
(activate-readline)
.EE
.RE
.
.SH ENVIRONMENT
.TP
.B LOKKE_HISTORY
Specifies the path to the REPL history file.  Defaults to
.B $XDG_CACHE_HOME/lokke/history
when
.B XDG_CACHE_HOME
is set, otherwise
.BR $HOME/.cache/lokke/history .
.
.SH SEE ALSO
.
.IR guile (1),
and for much more detail, the
.UR https://www.gnu.org/software/guile/manual/html_node/index.html
Guile Reference Manual
.UE
which may also be available via
.BR info\ guile
or
.B M\-x info
in emacs.
